# A0141054W
###### /java/hard2do/taskmanager/ui/TaskDetail.java
``` java

/**
 * The task details on the right panel
 * Able to do click and edit
 */
public class TaskDetail extends UiPart {
    private final Logger logger = LogsCenter.getLogger(TaskDetail.class);
    private static final String FXML = "TaskDetail.fxml";
    private Logic logic;
    private String newContent;
    private String formattedString;
    private int index;
    private ReadOnlyTask task;
    private LocalDate newDate;
    private LocalTime newTime;
    private ResultDisplay resultDisplay;
    private CommandResult mostRecentResult;

    private AnchorPane placeHolderPane;
    private AnchorPane taskDetailPane;

    @FXML
    private DatePicker startDatePicker;
    @FXML
    private DatePicker endDatePicker;
    @FXML
    private VBox detailView;
    @FXML
    private JFXTextField content;
    @FXML
    private Label tags;
    @FXML
    private JFXDatePicker startTimePicker;
    @FXML
    private JFXDatePicker endTimePicker;

    public TaskDetail() {
    }

    public static TaskDetail load(Stage primaryStage, AnchorPane placeHolder, ResultDisplay resultDisplay,
            Logic logic) {
        TaskDetail detail = UiPartLoader.loadUiPart(primaryStage, placeHolder, new TaskDetail());
        detail.configure(resultDisplay, logic);
        detail.addToPlaceHolder();
        detail.initializeTextField();
        return detail;
    }

    private void configure(ResultDisplay resultDisplay, Logic logic) {
        this.logic = logic;
        this.resultDisplay = resultDisplay;
    }

    private void initializeTextField() {
        RequiredFieldValidator validator = new RequiredFieldValidator();
        content.getValidators().add(validator);
        validator.setMessage("No Input Given");
        // Listener for content
        content.focusedProperty().addListener(new ChangeListener<Boolean>() {
            @Override
            public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) {
                if (!newValue) {
                    content.validate();
                }
            }
        });
        // Listener for startTimePicker
        startTimePicker.timeProperty().addListener(new ChangeListener<LocalTime>() {

            @Override
            public void changed(ObservableValue<? extends LocalTime> observable, LocalTime oldValue,
                    LocalTime newValue) {
                try {
                    handleStartTimeChanged();
                } catch (ParseException e) {
                }
            }
                
        });
        // Listener for endTimePicker
        endTimePicker.timeProperty().addListener(new ChangeListener<LocalTime>() {

            @Override
            public void changed(ObservableValue<? extends LocalTime> observable, LocalTime oldValue,
                    LocalTime newValue) {
                try {
                    handleEndTimeChanged();
                } catch (ParseException e) {
                }
            }
                
        });
    }

    public void loadTaskDetail(ReadOnlyTask task, int index) {
        this.index = index + 1;
        this.task = task;
        this.fillTaskDetail();
    }
    
    
    public void fillTaskDetail() {
        if (task.getContent() != null)
            content.setText(task.getContent().toString());
        
        if (task.getDate() != null && DateTimeUtil.changeDateToLocalDate(task.getDate().getValue()) != null) {
            startDatePicker.setValue(DateTimeUtil.changeDateToLocalDate(task.getDate().getValue()));
        } else {
            startDatePicker.setValue(null);
        }
        
        if (task.getTime() != null && DateTimeUtil.changeDateToLocalTime(task.getTime().getValue()) != null) {
            startTimePicker.setTime(DateTimeUtil.changeDateToLocalTime(task.getTime().getValue()));
        } else {
            startTimePicker.setTime(LocalTime.MIN);
        }
        
        if (task.getEndDate() != null && DateTimeUtil.changeDateToLocalDate(task.getEndDate().getValue()) != null) {
            endDatePicker.setValue(DateTimeUtil.changeDateToLocalDate(task.getEndDate().getValue()));
        } else {
            endDatePicker.setValue(null);
        }
        
        if (task.getEndTime() !=null && DateTimeUtil.changeDateToLocalTime(task.getEndTime().getValue()) != null) {
            endTimePicker.setTime(DateTimeUtil.changeDateToLocalTime(task.getEndTime().getValue()));
        } else {
            endTimePicker.setTime(LocalTime.MIN);
        }
        tags.setText(task.tagsString());
    }
    
    @FXML
    private void handleContentChanged() throws ParseException {
        newContent = content.getText();
        mostRecentResult = logic.execute("edit " + index + " c/" + newContent);
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }

    @FXML
    private void handleStartDateChanged() throws ParseException {
        newDate = startDatePicker.getValue();
        formattedString = DateTimeUtil.changeLocalDateToFormattedString(newDate);
        if (formattedString.compareTo(task.getDate().toString()) != 0) {
            mostRecentResult = logic.execute("edit " + index + " sd/" + formattedString);
            resultDisplay.postMessage(mostRecentResult.feedbackToUser);
            logger.info("Result: " + mostRecentResult.feedbackToUser);
        }
    }
    
    @FXML
    private void handleEndDateChanged() throws ParseException {
        newDate = endDatePicker.getValue();
        formattedString = DateTimeUtil.changeLocalDateToFormattedString(newDate);
        if (formattedString.compareTo(task.getDate().toString()) != 0) {
            mostRecentResult = logic.execute("edit " + index + " ed/" + formattedString);
            resultDisplay.postMessage(mostRecentResult.feedbackToUser);
            logger.info("Result: " + mostRecentResult.feedbackToUser);
        }
    }
    
    @FXML
    private void handleStartTimeChanged() throws ParseException {
        newTime = startTimePicker.getTime();
        formattedString = DateTimeUtil.changeLocalTimeToFormattedString(newTime);
        System.out.println(formattedString + " " + task.getTime().toString()); 
        if (formattedString.compareTo(task.getTime().toString()) != 0) {
            mostRecentResult = logic.execute("edit " + index + " st/" + formattedString);
            resultDisplay.postMessage(mostRecentResult.feedbackToUser);
            logger.info("Result: " + mostRecentResult.feedbackToUser);
        }
    }
    
    @FXML
    private void handleEndTimeChanged() throws ParseException {
        newTime = endTimePicker.getTime();
        formattedString = DateTimeUtil.changeLocalTimeToFormattedString(newTime);
        System.out.println(formattedString + " " + task.getTime().toString()); 
        if (formattedString.compareTo(task.getTime().toString()) != 0) {
            mostRecentResult = logic.execute("edit " + index + " et/" + formattedString);
            resultDisplay.postMessage(mostRecentResult.feedbackToUser);
            logger.info("Result: " + mostRecentResult.feedbackToUser);
        }
    }

    private void addToPlaceHolder() {
        placeHolderPane.getChildren().add(detailView);
    }

    @Override
    public void setNode(Node node) {
        taskDetailPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### /java/hard2do/taskmanager/ui/UiManager.java
``` java
    @Subscribe
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, refreshing TaskDetail"));
        mainWindow.getTaskDetail().fillTaskDetail();
        try {
			logic.execute("list");
		} catch (ParseException e) {
		    logger.warning("cannot list after task manager is changed");
		}
    }
}
```
###### /java/hard2do/taskmanager/ui/CommandBox.java
``` java
    public void configure(ResultDisplay resultDisplay, Logic logic) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        AutoCompletionBinding<String> acb = TextFields.bindAutoCompletion(commandTextField,
                FXCollections.observableArrayList("select", "list", "add", "clear",
                                                    "delete", "edit", "find", "findtag", 
                                                    "addtag", "deltag", "list all", "list done",
                                                    "list important", "list unimportant",
                                                    "done", "important", "unportant",
                                                    "next", "load", "help", "exit", "save", "undo"));

        acb.setOnAutoCompleted(new EventHandler<AutoCompletionBinding.AutoCompletionEvent<String>>() {
            @Override
            public void handle(AutoCompletionEvent<String> event) {
                String valueFromAutoCompletion = event.getCompletion();
            }
        });
        registerAsAnEventHandler(this);
    }

```
###### /java/hard2do/taskmanager/commons/core/GmailService.java
``` java
/**
 * In charge of connecting to gmail to retrieve data
 */
public class GmailService {
    private final static Logger logger = LogsCenter.getLogger(GmailService.class);
    
    /** Application name on google. */
    private static final String APPLICATION_NAME = "Gmail API Java Quickstart";

    /** Directory to store user credentials for this application. */
    private static final java.io.File DATA_STORE_DIR = new java.io.File(System.getProperty("user.home"),
            ".credentials/gmail-java-quickstart");

    /** Global instance of the {@link FileDataStoreFactory}. */
    private static FileDataStoreFactory DATA_STORE_FACTORY;

    /** Global instance of the JSON factory. */
    private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();

    /** Global instance of the HTTP transport. */
    private static HttpTransport HTTP_TRANSPORT;

    /**
     * Global instance of the scopes required by this quickstart.
     *
     * If modifying these scopes, delete your previously saved credentials at
     * ~/.credentials/gmail-java-quickstart
     */
    private static final List<String> SCOPES = Arrays.asList(GmailScopes.GMAIL_READONLY);

    static {
        try {
            HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
            DATA_STORE_FACTORY = new FileDataStoreFactory(DATA_STORE_DIR);
        } catch (Throwable t) {
            t.printStackTrace();
            System.exit(1);
        }
    }

    /**
     * Creates an authorized Credential object.
     * 
     * @return an authorized Credential object.
     * @throws IOException
     */
    public static Credential authorize() throws IOException {
        logger.info("authorizing gmail");
        // Load client secrets.
        InputStream in = GmailService.class.getResourceAsStream("/client_secret.json");
        GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));

        // Build flow and trigger user authorization request.
        GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(HTTP_TRANSPORT, JSON_FACTORY,
                clientSecrets, SCOPES).setDataStoreFactory(DATA_STORE_FACTORY).setAccessType("offline").build();
        Credential credential = new AuthorizationCodeInstalledApp(flow, new LocalServerReceiver()).authorize("user");
        logger.info("Credentials saved to " + DATA_STORE_DIR.getAbsolutePath());
        return credential;
    }

    /**
     * Build and return an authorized Gmail client service.
     * 
     * @return an authorized Gmail client service
     * @throws IOException
     */
    public static Gmail getGmailService() throws IOException {
        logger.info("connecting to gmail server");
        Credential credential = authorize();
        return new Gmail.Builder(HTTP_TRANSPORT, JSON_FACTORY, credential).setApplicationName(APPLICATION_NAME).build();
    }
    
    /**
     * List all subjects of Messages of the user's mailbox matching the query.
     *
     * @param service
     *            Authorized Gmail API instance.
     * @param userId
     *            User's email address. The special value "me" can be used to
     *            indicate the authenticated user.
     * @param query
     *            String used to filter the Messages listed.
     * @throws IOException
     */
    public static List<String> listSubjectsMatchingQuery(Gmail service, String userId, String query)
            throws IOException {
        List<Message> messages = GmailService.listMessagesMatchingQuery(service, userId, query);
        List<String> subjects = new ArrayList<String>();

        for (Message message : messages) {
            Message currentMessage = service.users().messages().get(userId, message.getId()).execute();
            List<MessagePartHeader> headers = currentMessage.getPayload().getHeaders();
            for (MessagePartHeader header : headers) {
                if (header.getName().compareTo("Subject") == 0) {
                    subjects.add(header.getValue());
                }
            }
        }

        return subjects;
    }

    /**
     * List all Messages of the user's mailbox matching the query.
     *
     * @param service
     *            Authorized Gmail API instance.
     * @param userId
     *            User's email address. The special value "me" can be used to
     *            indicate the authenticated user.
     * @param query
     *            String used to filter the Messages listed.
     * @throws IOException
     */
    public static List<Message> listMessagesMatchingQuery(Gmail service, String userId, String query)
            throws IOException {
        ListMessagesResponse response = service.users().messages().list(userId).setQ(query).execute();

        List<Message> messages = new ArrayList<Message>();
        while (response.getMessages() != null) {
            messages.addAll(response.getMessages());
            if (response.getNextPageToken() != null) {
                String pageToken = response.getNextPageToken();
                response = service.users().messages().list(userId).setQ(query).setPageToken(pageToken).execute();
            } else {
                break;
            }
        }
        return messages;
    }

}
```
###### /java/hard2do/taskmanager/commons/core/Messages.java
``` java
    public static final String MESSAGE_INVALID_EMAIL_FORMAT = "Invalid email format!";     
}
```
###### /java/hard2do/taskmanager/commons/util/DateTimeUtil.java
``` java

/**
 * Change the data type of date front Date to LocalDate and the other way around
 * as well as Date and LocalTime
 */
public class DateTimeUtil {
    
    public static LocalDate changeDateToLocalDate(Date value) {
        if (value == null || value.toInstant() == null)
            return null;
        Instant instant = value.toInstant();
        ZonedDateTime zdt = instant.atZone(ZoneId.systemDefault());
        LocalDate date = zdt.toLocalDate();
        return date;
    }
    
    public static LocalTime changeDateToLocalTime(Date value) {
        if (value == null || value.toInstant() == null)
            return null;
        Instant instant = value.toInstant();
        ZonedDateTime zdt = instant.atZone(ZoneId.systemDefault());
        LocalTime time = zdt.toLocalTime();
        return time;
    }
    
    public static String changeLocalDateToFormattedString(LocalDate value) {
        if (value == null)
            return "";
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy");
        String formattedString = value.format(formatter);
        return formattedString;
    }
    
    public static String changeLocalTimeToFormattedString(LocalTime value) {
        if (value == null)
            return "";
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm");
        String formattedString = value.format(formatter);
        return formattedString;
    }
}
```
###### /java/hard2do/taskmanager/logic/commands/ListCommand.java
``` java
/**
 * Lists all task in the task manager to the user.
 * optional to list done, undone, important, unimportant
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_SUCCESS_ALL = "Listed all tasks";
    
    public static final String MESSAGE_SUCCESS_DONE = "Listed all done tasks";
    
    public static final String MESSAGE_SUCCESS_UNDONE = "Listed all undone tasks";
  
    public static final String MESSAGE_LIST_RESTRICTION = "Hard2Do can only list all, list done all list undone";
    
    public static final String MESSAGE_SUCCESS_IMPORTANT = "Listed all important tasks";
    
    public static final String MESSAGE_SUCCESS_UNIMPORTANT = "Listed all unimportant tasks";
    
    private String listModification;
    
    public ListCommand(String args) {
        this.listModification = args.trim().toLowerCase();
    }

    @Override
    public CommandResult execute() {
        if (listModification.equals("done") || listModification.equals("-d")) {
            model.updateFilteredListToShowDone();
            return new CommandResult(MESSAGE_SUCCESS_DONE);
        } else if (listModification.equals("all") || listModification.equals("-a")) {
            model.updateFilteredListToShowAll();
            return new CommandResult(MESSAGE_SUCCESS_ALL);
        } else if (listModification.equals("important") || listModification.equals("-i")){
        	model.updateFilteredListToShowImportant();
            return new CommandResult(MESSAGE_SUCCESS_IMPORTANT);
        } else if (listModification.equals("unimportant") || listModification.equals("-ui")){
        	model.updateFilteredListToShowUnimportant();
            return new CommandResult(MESSAGE_SUCCESS_UNIMPORTANT);
        } else if (listModification.equals("undone") || listModification.equals("-ud")){
        	model.updateFilteredListToShowUndone();
            return new CommandResult(MESSAGE_SUCCESS_UNDONE);
        } else {
            model.updateFilteredListToShowUndone();
            return new CommandResult(MESSAGE_SUCCESS_UNDONE);
        }
    }
}
```
###### /java/hard2do/taskmanager/logic/commands/EmailCommand.java
``` java
/**
 * Adds a new task from unread email to task manager.
 */
public class EmailCommand extends Command {

    public static final String COMMAND_WORD = "email";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": adds unread email as tasks to Hard2Do. \n"
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Unread Email added to Hard2Do";
    
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in Hard2Do. Try to mark read those emails that you have added before!";
    
    public static final String MESSAGE_NO_CONNECTION = "Cannot connect to gmail server";

    private static final String MESSAGE_NO_UNREAD_EMAIL = "There is currently no unread email";
    
    private String email;
    
    public EmailCommand(String email) {
        this.email = email;
    }

    @Override
    public CommandResult execute() {
        List<String> unreadMessages;
        Gmail service = null;
        String user = "me";
        String query;
        if (email != "") {
            query = "from:" + email + " is:unread";
        } else {
            query = "is:unread";
        }
        ReadOnlyTask toAdd = null;
        
        try {
            service = GmailService.getGmailService();
        } catch (IOException e) {
            return new CommandResult(MESSAGE_NO_CONNECTION);
        }

        try {
            unreadMessages = GmailService.listSubjectsMatchingQuery(service, user, query);
        } catch (IOException e) {
            return new CommandResult(MESSAGE_NO_CONNECTION);
        }

        if (unreadMessages.isEmpty()) {
            return new CommandResult(MESSAGE_NO_UNREAD_EMAIL);
        } else {
            assert model != null;
            for (String message : unreadMessages) {
                try {
                    toAdd = new Task(
                            new Content(message),
                            new TaskDate(),
                            new TaskTime(),
                            new UniqueTagList(new HashSet<>()));
                } catch (IllegalValueException e) {
                }
                try {
                    model.addTask(toAdd);
                } catch (DuplicateTaskException e) {
                    return new CommandResult(MESSAGE_DUPLICATE_TASK);
                }
            }
        }
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### /java/hard2do/taskmanager/logic/commands/LoadCommand.java
``` java
/**
 * Loads data from a specific file
 */
public class LoadCommand extends Command {

	public static final String COMMAND_WORD = "load";

	public static final String MESSAGE_SUCCESS = "New storage file loaded. Please restart Hard2Do to apply results!!!";

	public static final String MESSAGE_INVALID_FILEPATH = "The file path entered is not valid!";

	public static final String MESSAGE_DIRECTORY_FILEPATH = "The file path entered is a directory. Please enter a file!";

	public static final String MESSAGE_INVALID_FILENAME = "The file name entered is not valid";

	private String taskManagerFilePath;

	public LoadCommand(String taskManagerFilePath) {
		this.taskManagerFilePath = taskManagerFilePath;
	}

	@Override
	public CommandResult execute() {
		assert config != null;

		if (!taskManagerFilePath.contains(".xml")) {
			return new CommandResult(MESSAGE_INVALID_FILENAME);
		}

		if (!taskManagerFilePath.contains("/")) {
			return new CommandResult(MESSAGE_INVALID_FILEPATH);
		}

		config.setTaskManagerFilePath(taskManagerFilePath);
		try {
			ConfigUtil.saveConfig(config, config.DEFAULT_CONFIG_FILE);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return new CommandResult(MESSAGE_SUCCESS);
	}

}
```
###### /java/hard2do/taskmanager/logic/parser/Parser.java
``` java
	public static final Pattern VALID_EMAIL_ADDRESS_FORMAT = Pattern
			.compile("^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,6}$", Pattern.CASE_INSENSITIVE);

	private static final ArrayList<String> listKeywords = new ArrayList<>(
			Arrays.asList("all", "done", "undone", "important", "unimportant", 
					"-a", "-d", "-ud", "-ui", "-i", ""));

	public Parser() {
	}

	/**
	 * Parses user input into command for execution.
	 *
	 * @param userInput
	 *            full user input string
	 * @return the command based on the user input
	 * @throws ParseException
	 */
	public Command parseCommand(String userInput) throws ParseException {
		final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
		if (!matcher.matches()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
		}

		final String commandWord = matcher.group("commandWord");
		final String arguments = matcher.group("arguments");
		switch (commandWord.toLowerCase()) {

		case AddCommand.COMMAND_WORD:
			return prepareAdd(arguments);

		case SelectCommand.COMMAND_WORD:
			return prepareSelect(arguments);

		case DeleteCommand.COMMAND_WORD:
			return prepareDelete(arguments);

		case ClearCommand.COMMAND_WORD:
			return new ClearCommand();

		case FindCommand.COMMAND_WORD:
			return prepareFind(arguments);

		case FindTagCommand.COMMAND_WORD:
			return prepareFindTag(arguments);

		case ListCommand.COMMAND_WORD:
			return prepareList(arguments);

		case ExitCommand.COMMAND_WORD:
			return new ExitCommand();

```
###### /java/hard2do/taskmanager/logic/parser/Parser.java
``` java
		case EmailCommand.COMMAND_WORD:
			return prepareEmail(arguments);

		default:
			return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
		}
	}
	
```
###### /java/hard2do/taskmanager/logic/parser/Parser.java
``` java
	/**
	 * Parses arguments in the context of the list task command.
	 *
	 * @param done,
	 *            undone, all
	 * @return the prepared command
	 * @throws ParseException
	 */
	private Command prepareList(String args) throws ParseException {
		if (!listKeywords.contains(args.trim().toLowerCase())) {
			return new IncorrectCommand(
					String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_LIST_RESTRICTION));
		} else {
			return new ListCommand(args.trim());
		}
	}

	/**
	 * Parses arguments in the context of the email command.
	 *
	 * @param args
	 *            should be an email address
	 * @return the prepared command
	 * @throws ParseException
	 */
	private Command prepareEmail(String arg) throws ParseException {
		String email = arg.trim();
		if (email.compareTo("") == 0) {
			return new EmailCommand("");
		}
		final Matcher matcher = VALID_EMAIL_ADDRESS_FORMAT.matcher(email);
		if (!matcher.matches()) {
			return new IncorrectCommand(MESSAGE_INVALID_EMAIL_FORMAT);
		} else {
			return new EmailCommand(email);
		}
	}
```
###### /java/hard2do/taskmanager/logic/parser/Parser.java
``` java
	/**
	 * Parses arguments in the context of the load command.
	 *
	 * @param args
	 *            should be the file path
	 * @return the prepared command
	 * @throws ParseException
	 */
	private Command prepareLoad(String args) throws ParseException {
		File file = new File(args.trim());
		if (file.isDirectory()) {
			return new IncorrectCommand(
					String.format(MESSAGE_INVALID_COMMAND_FORMAT, LoadCommand.MESSAGE_DIRECTORY_FILEPATH));
		} else if (!file.exists()) {
			return new IncorrectCommand(
					String.format(MESSAGE_INVALID_COMMAND_FORMAT, LoadCommand.MESSAGE_INVALID_FILEPATH));
		} else {
			return new LoadCommand(args.trim());
		}
	}

	/**
	 * Parses arguments in the context of the add tag command.
	 *
	 * @param args
	 *            should be a valid tag
	 * @return the prepared command
	 * @throws ParseException
	 */
	private Command prepareAddTags(String args) throws ParseException {
		Matcher matcher = ADD_TAGS_FORMAT.matcher(args.trim());
		// Validate arg string format
		if (!matcher.matches()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddTagCommand.MESSAGE_USAGE));
		}

		try {
			return new AddTagCommand(matcher.group("index"), matcher.group("tagsToAdd"));

		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}
	}

	/**
	 * Parses arguments in the context of the delete tag command.
	 *
	 * @param args
	 *            should be a valid tag
	 * @return the prepared command
	 * @throws ParseException
	 */
	private Command prepareDeleteTags(String args) throws ParseException {
		Matcher matcher = DELETE_TAGS_FORMAT.matcher(args.trim());
		// Validate arg string format
		if (!matcher.matches()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteTagCommand.MESSAGE_USAGE));
		}

		try {
			return new DeleteTagCommand(matcher.group("index"), matcher.group("tagsToDelete"));
		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}
	}

	/**
	 * Extracts the new task's tags from the add command's tag arguments string.
	 * Merges duplicate tag strings.
	 */
	private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
		// no tags
		if (tagArguments.isEmpty()) {
			return Collections.emptySet();
		}
		// replace first delimiter prefix, then split
		final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst(" #", "").split(" #"));
		return new HashSet<>(tagStrings);
	}

	/**
	 * Parses arguments in the context of the delete person command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 */
	private Command prepareDelete(String args) {

		Optional<Integer> index = parseIndex(args);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
		}
		
		return new DeleteCommand(index.get());
	}

	/**
	 * Parses arguments in the context of the done person command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 */
```
###### /java/hard2do/taskmanager/logic/parser/Parser.java
``` java
	private Command prepareSelect(String args) {
		Optional<Integer> index = parseIndex(args);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
		}

		return new SelectCommand(index.get());
	}

	/**
	 * Returns the specified index in the {@code command} IF a positive unsigned
	 * integer is given as the index. Returns an {@code Optional.empty()}
	 * otherwise.
	 */
	private Optional<Integer> parseIndex(String command) {
		final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
		if (!matcher.matches()) {
			return Optional.empty();
		}

		String index = matcher.group("targetIndex");
		if (!StringUtil.isUnsignedInteger(index)) {
			return Optional.empty();
		}
		return Optional.of(Integer.parseInt(index));

	}

	/**
	 * Parses arguments in the context of the find task command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 */
```
###### /resources/view/TaskListCard.fxml
``` fxml

<HBox id="cardPane" fx:id="cardPane" prefHeight="63.0" prefWidth="393.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane prefHeight="70.0" prefWidth="250.0" HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
                <ColumnConstraints hgrow="SOMETIMES" maxWidth="100.0" minWidth="10.0" prefWidth="100.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" maxHeight="150.0" minHeight="50.0" prefHeight="71.0" prefWidth="150.0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>

                    <children>
                        <HBox alignment="CENTER_LEFT" prefHeight="20.0" prefWidth="232.0" spacing="5">
                            <children>
                                <HBox prefHeight="20.0" prefWidth="90.0">
                           <Circle fx:id="importantCircle" fill="#08eb40" radius="6.0" stroke="BLACK" strokeType="INSIDE">
                              <HBox.margin>
                                 <Insets top="3.0" />
                              </HBox.margin>
                           </Circle>
                           <CheckBox fx:id="doneCheckBox" mnemonicParsing="false" onAction="#handleDoneCheckBox">
                              <HBox.margin>
                                 <Insets left="5.0" />
                              </HBox.margin></CheckBox>
                                    <Label fx:id="id" minWidth="30.0" styleClass="cell_big_label" />
                                    <Label fx:id="content" minWidth="300.0" prefHeight="20.0" prefWidth="140.0" styleClass="cell_big_label" text="\$first" />
                                </HBox>
                                <Label fx:id="tags" styleClass="cell_small_label" text="\$tags">
                           <HBox.margin>
                              <Insets />
                           </HBox.margin></Label>
                            </children>
                        </HBox>
                    </children>
                </VBox>
            <HBox prefHeight="100.0" prefWidth="200.0" GridPane.columnIndex="1">
               <children>
                  <Label fx:id="date" alignment="CENTER_RIGHT" contentDisplay="RIGHT" text="13-12-2016">
                     <HBox.margin>
                        <Insets top="25.0" />
                     </HBox.margin>
                  </Label>
               </children>
            </HBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
###### /resources/view/TaskDetail.fxml
``` fxml

<AnchorPane prefHeight="441.0" prefWidth="319.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="hard2do.taskmanager.ui.TaskDetail">
   <children>
      <VBox fx:id="detailView" layoutY="-121.0" prefHeight="280.0" prefWidth="319.0" style="-fx-background-color: white;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
         <children>
            <JFXTextField fx:id="content" maxWidth="319.0" minWidth="319.0" onAction="#handleContentChanged" prefHeight="59.0" prefWidth="319.0" promptText="Enter Content" text="Something">
               <font>
                  <Font name="Abyssinica SIL" size="33.0" />
               </font>
               <VBox.margin>
                  <Insets bottom="20.0" top="30.0" />
               </VBox.margin>
            </JFXTextField>
            <Separator prefWidth="200.0" />
            <Separator prefWidth="200.0" />
            <Separator prefWidth="200.0" />
            <SplitPane dividerPositions="0.5, 0.5, 0.5, 0.5" orientation="VERTICAL" prefHeight="316.0" prefWidth="319.0" style="-fx-background-color: white;">
              <items>
                <AnchorPane minHeight="60.0" minWidth="60.0" prefHeight="60.0" prefWidth="317.0">
                     <children>
                        <SplitPane dividerPositions="0.27" prefHeight="160.0" prefWidth="200.0" style="-fx-background-color: white;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                          <items>
                            <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                                 <children>
                                    <Label layoutX="27.0" layoutY="24.0" prefHeight="63.0" prefWidth="79.0" text="Start/Due" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                       <padding>
                                          <Insets left="5.0" />
                                       </padding>
                                    </Label>
                                 </children>
                              </AnchorPane>
                            <AnchorPane fx:id="timePane" minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                                 <children>
                                    <JFXDatePicker fx:id="startDatePicker" layoutY="9.0" onAction="#handleStartDateChanged" />
                                 </children></AnchorPane>
                          </items>
                        </SplitPane>
                     </children>
                  </AnchorPane>
                  <AnchorPane layoutX="10.0" layoutY="10.0" minHeight="60.0" minWidth="60.0" prefHeight="60.0" prefWidth="160.0">
                     <children>
                        <SplitPane dividerPositions="0.27" prefHeight="160.0" prefWidth="200.0" style="-fx-background-color: white;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                           <items>
                              <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                                 <children>
                                    <Label layoutX="27.0" layoutY="24.0" prefHeight="63.0" prefWidth="79.0" text="End" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                       <padding>
                                          <Insets left="5.0" />
                                       </padding>
                                    </Label>
                                 </children>
                              </AnchorPane>
                              <AnchorPane fx:id="timePane1" minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                                 <children>
                                    <JFXDatePicker fx:id="endDatePicker" layoutY="9.0" onAction="#handleEndDateChanged" />
                                 </children>
                              </AnchorPane>
                           </items>
                        </SplitPane>
                     </children>
                  </AnchorPane>
                <AnchorPane minHeight="60.0" minWidth="0.0" prefHeight="60.0" prefWidth="160.0">
                     <children>
                        <SplitPane dividerPositions="0.27" prefHeight="160.0" prefWidth="200.0" style="-fx-background-color: white;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                          <items>
                            <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                                 <children>
                                    <Label layoutX="8.0" layoutY="6.0" text="Start/Due" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                       <padding>
                                          <Insets left="5.0" />
                                       </padding>
                                    </Label>
                                 </children>
                              </AnchorPane>
                            <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                                 <children>
                                    <JFXDatePicker fx:id="startTimePicker" layoutY="13.0" onAction="#handleStartTimeChanged" showTime="true" />
                                 </children>
                              </AnchorPane>
                          </items>
                        </SplitPane>
                     </children>
                  </AnchorPane>
                  <AnchorPane layoutX="10.0" layoutY="10.0" minHeight="60.0" minWidth="0.0" prefHeight="60.0" prefWidth="160.0">
                     <children>
                        <SplitPane dividerPositions="0.27" prefHeight="160.0" prefWidth="200.0" style="-fx-background-color: white;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                           <items>
                              <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                                 <children>
                                    <Label layoutX="8.0" layoutY="6.0" text="End" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                       <padding>
                                          <Insets left="5.0" />
                                       </padding>
                                    </Label>
                                 </children>
                              </AnchorPane>
                              <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                                 <children>
                                    <JFXDatePicker fx:id="endTimePicker" layoutY="13.0" onAction="#handleEndTimeChanged" showTime="true" />
                                 </children>
                              </AnchorPane>
                           </items>
                        </SplitPane>
                     </children>
                  </AnchorPane>
                  <AnchorPane minHeight="60.0" minWidth="60.0" prefHeight="60.0" prefWidth="160.0">
                     <children>
                        <SplitPane dividerPositions="0.27" prefHeight="160.0" prefWidth="200.0" style="-fx-background-color: white;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                          <items>
                            <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                                 <children>
                                    <Label layoutX="20.0" layoutY="20.0" text="Tag" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                       <padding>
                                          <Insets left="5.0" />
                                       </padding>
                                    </Label>
                                 </children>
                              </AnchorPane>
                            <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                                 <children>
                                    <Label fx:id="tags" layoutX="27.0" layoutY="6.0" text="wow" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                       <padding>
                                          <Insets left="5.0" />
                                       </padding>
                                    </Label>
                                 </children>
                              </AnchorPane>
                          </items>
                        </SplitPane>
                     </children>
                  </AnchorPane>
              </items>
               <VBox.margin>
                  <Insets />
               </VBox.margin>
            </SplitPane>
         </children>
      </VBox>
   </children>
</AnchorPane>
```
