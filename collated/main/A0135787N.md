# A0135787N
###### /java/seedu/address/model/History.java
``` java

public class History {
	
	
	public static class StateNotFoundException extends Exception {} 
	
	
	private Stack<List<ReadOnlyTask>> taskStates;
	private Stack<Collection<Tag>> tagStates;
	private Stack <String> messages;
	private List<ReadOnlyTask> tasksState;
	private Collection<Tag> tagsState;
	
	private String message;

	/**

	 * Constructor that initialises History class whenever Hard2Do is started
	 */
	
	History(){
		taskStates =  new Stack <List<ReadOnlyTask>>(); 
		messages = new Stack<String>();
		tagStates = new Stack <Collection<Tag>>();
		tagsState = FXCollections.observableArrayList();
	}
	
	/*
	 * method to save and store the existing state of the TaskManger before any overwrite operations
	 */
	public void save(ObservableList<ReadOnlyTask> stateToSave, ObservableList<Tag> tagsToSave, String commandType) 
			throws IllegalValueException, ParseException{
		
		if (stateToSave.isEmpty())
			return;
		
		ObservableList<ReadOnlyTask> newState = FXCollections.observableArrayList();
		
		//Create deep copy of tasks
		for(ReadOnlyTask t : stateToSave){
			
			Set<Tag> tagSet = new HashSet<>();
	        for (Tag tag : t.getTags().toSet()) {
	            tagSet.add(new Tag(tag.tagName));
	        }
	        

	        TaskDate td = new TaskDate(t.getDate());
	        TaskDate ed = new TaskDate(t.getEndDate());
	        TaskTime tt = new TaskTime(t.getTime());
	        TaskTime et = new TaskTime(t.getEndTime());
	        
	        Integer duration = null;
	        
```
###### /java/seedu/address/model/person/Content.java
``` java
public class Content {
    
    public static final String MESSAGE_CONTENT_CONSTRAINTS = "Task Content can be in any format";
    public static final String CONTENT_VALIDATION_REGEX = ".+";

    public String value;

    public Content(){
    	
    }
    
    /**
     * Validates given Content.
     *
     * @throws IllegalValueException if given Content string is invalid.
     */
    public Content(String contentString) throws IllegalValueException {
        assert contentString != null;
        if (!isValidContent(contentString)) {
            throw new IllegalValueException(MESSAGE_CONTENT_CONSTRAINTS);
        }
        this.value = contentString;
    }

    /**
     * Returns true if a given string is a valid task content.
     */
    public static boolean isValidContent(String test) {
        return test.matches(CONTENT_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Content // instanceof handles nulls
                && this.value.equals(((Content) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/address/model/person/TaskTime.java
``` java
public class TaskTime {

    public static final String MESSAGE_TIME_CONSTRAINTS = "Task time should only follow this format HH:MM";
    public static final String TASKTIME_VALIDATION_REGEX = "([01]?[0-9]|2[0-3]):[0-5][0-9]";

    
    public Date value;
    public String timeString;
    
    public TaskTime() {
    	timeString = "";
    }
    
    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     * @throws ParseException 
     */
    public TaskTime(String timeString) throws IllegalValueException, ParseException {
    	   assert timeString != null;
    	   this.timeString = timeString.trim();
    	   if(!isValidTaskTime(timeString)) {
    		   throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
    	   }
    	   
    	   SimpleDateFormat simpleDateFormat = new SimpleDateFormat("HH:mm");
    	   
    	   Date time = simpleDateFormat.parse(timeString);
    	   this.value = time;
       }
    
    public TaskTime(TaskTime oldTaskTime) {
    	if(oldTaskTime == null) {
    		this.timeString = "";
    	}
    	
    	else {
    		this.timeString = oldTaskTime.timeString;
    		this.value = oldTaskTime.value;
    	}
    }
    
    /**
     * Returns true if a given string is a valid date.
     */
    public static boolean isValidTaskTime(String test) {
        return test.matches(TASKTIME_VALIDATION_REGEX);
    }
 
    
    public Date getValue() {
        return value;
    }
    
    
    @Override
    public String toString() {    	
    		return timeString;
    	}


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskTime // instance of handles nulls
                && this.value.equals(((TaskTime) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/address/model/person/TaskDate.java
``` java
	public static boolean isValidTaskDate(String test) {
		return test.matches(TASKDATE_VALIDATION_REGEX);
	}
	
	public Date getValue() {
		return value;
	}

	@Override
	public String toString() {
		// return value.toString();
		return dateString;

	}

	@Override
    public boolean equals(Object other) {
    	if (other != null) {
    		return other == this // short circuit if same object
                || (other instanceof TaskDate // instance of handles nulls
                && this.value.equals(((TaskDate) other).value)); // state check
    	}
    	else 
    		return false;
    }

	@Override
	public int hashCode() {
		return value.hashCode();
	}

}
```
###### /java/seedu/address/commons/util/InferTimeUtil.java
``` java
public class InferTimeUtil {
	
	private String contentToInfer;
	private String inferredTime;
	private String startTime;
	private String endTime;
	private static final Pattern TIME_FORMAT =
    		Pattern.compile("at (?<time>[0-9]+)(?<meridiem>[amp]+)?");
	
	private static final Pattern START_END_TIME_FORMAT =
			Pattern.compile("from (?<startTime>[0-9]+)(?<smeridiem>[amp]+)? to "
					+ "(?<endTime>[0-9]+)(?<emeridiem>[amp]+)?");
	
	/**
	 * Constructor that takes in content to infer.
	 * 
	 * @param content
	 */
	
	public InferTimeUtil(String content){
		assert content != null;
		
	    contentToInfer = content;
	    
	}
	
	/**
	 * Default Constructor
	 * 
	 */
	
	public InferTimeUtil(){


	}
	
	/**
	 * finds a possible time that is implied within the content and stores it.
	 * 
	 * @return true if found else false.
	 * 
	 */
	
	public boolean findTime(){
		Scanner sc = new Scanner(contentToInfer);
		String atTime = sc.findInLine(TIME_FORMAT);
		if (atTime != null){
			Matcher matcher = TIME_FORMAT.matcher(atTime);
			if(!matcher.matches()){
				sc.close();
				return false;
			}
			String numeral = matcher.group("time");
			String meridiem = matcher.group("meridiem").toLowerCase();
			int timePrefix = Integer.parseInt(numeral);
			
			if(timePrefix > 1259 && numeral.length() == 4 && timePrefix/100 > 59 
					|| timePrefix > 12 && numeral.length() <= 2){
				sc.close();
				return false;
				
			}if(numeral.length() < 3){
				timePrefix = timePrefix * 100;
				numeral = numeral + "00";
				
			}if(meridiem.equals("pm")){
				if(timePrefix < 1200){
					timePrefix += 1200;
					numeral = Integer.toString(timePrefix);
				}
				
			}if(meridiem.equals("am")){
				if(timePrefix >= 1200){
					timePrefix -= 1200;
					numeral = "00" + Integer.toString(timePrefix);
				}
			}
			sc.close();
			if(numeral.length() == 4){
				inferredTime = numeral.substring(0, 2) + ":" + numeral.substring(2);
				return true;
			}
			if(numeral.length() == 3){
				inferredTime = numeral.substring(0, 1) + ":" + numeral.substring(1);
				return true;
			}
			
		}
		sc.close();
		return false;
	}
	
	/**
	 * finds a possible time period that is implied within the content and stores it.
	 * 
	 * @return true if found else false.
	 * 
	 */
	public boolean findTimeToTime(){
		Scanner vc = new Scanner(contentToInfer);
		String timeToTime = vc.findInLine(START_END_TIME_FORMAT);
		
		if (timeToTime != null){
			Matcher matcher = START_END_TIME_FORMAT.matcher(timeToTime);
			if(!matcher.matches()){
				vc.close();
				return false;
			}
			
			startTime = obtainTime(matcher.group("startTime"), matcher.group("smeridiem"));
			endTime = obtainTime(matcher.group("endTime"), matcher.group("emeridiem"));
			if(startTime != null && endTime != null ){
				vc.close();
				return true;
			}
		
		}
		vc.close();
		return false;
	}
	
	public String obtainTime(String numeral, String meridiem){
		int timePrefix = Integer.parseInt(numeral);
		meridiem = meridiem.toLowerCase();
		
		if(timePrefix > 1259 && numeral.length() == 4 && timePrefix/100 > 59 
				|| timePrefix > 12 && numeral.length() <= 2){
			return null;
			
		}if(numeral.length() < 3){
			timePrefix = timePrefix * 100;
			numeral = numeral + "00";
			
		}if(meridiem.equals("pm")){
			if(timePrefix < 1200){
				timePrefix += 1200;
				numeral = Integer.toString(timePrefix);
			}
			
		}if(meridiem.equals("am")){
			if(timePrefix >= 1200){
				timePrefix -= 1200;
				numeral = "00" + Integer.toString(timePrefix);
			}
		}

		if(numeral.length() == 4){
			return numeral.substring(0, 2) + ":" + numeral.substring(2);

		}
		if(numeral.length() == 3){
			return numeral.substring(0, 1) + ":" + numeral.substring(1);
		}
		
		return null;
		
	}
	
	/**
	 * Getters to obtain times inferred from content.
	 * 
	 * @return null if there is no time. 
	 */
	
	public String getTime(){
		
	    return inferredTime;
	
	
	}
	public String getStartTime(){
		return startTime;
	}
	
	
	public String getEndTime(){
		return endTime;
	}
}
```
###### /java/seedu/address/commons/util/StringUtil.java
``` java
public class StringUtil {
    public static boolean containsIgnoreCase(String source, String query) {
        String[] split = source.toLowerCase().split("\\s+");
        List<String> strings = Arrays.asList(split);
        return strings.stream().filter(s -> s.equals(query.toLowerCase())).count() > 0;
    }

    /**
     * Returns a detailed message of the t, including the stack trace.
     */
    public static String getDetails(Throwable t){
        assert t != null;
        StringWriter sw = new StringWriter();
        t.printStackTrace(new PrintWriter(sw));
        return t.getMessage() + "\n" + sw.toString();
    }

    /**
     * Returns true if s represents an unsigned integer e.g. 1, 2, 3, ... <br>
     *   Will return false for null, empty string, "-1", "0", "+1", and " 2 " (untrimmed) "3 0" (contains whitespace).
     * @param s Should be trimmed.
     */
    public static boolean isUnsignedInteger(String s){
        return s != null && s.matches("^0*[1-9]\\d*$");
    }
}
```
###### /java/seedu/address/commons/util/InferDateUtil.java
``` java
public class InferDateUtil {
	
	private String contentToInfer;
	private Calendar calendar;
	private String inferredDate;
	private final SimpleDateFormat sdfDate = new SimpleDateFormat("dd-MM-yyyy");
	private Date now;
	private int currentDay;
	private int inferredDay;
	private HashMap<String, Integer> days;
	
	/**
	 * Constructor that obtains today's date and day of the week.
	 * Passes in content to infer.
	 * 
	 * @param content
	 */
	
	public InferDateUtil(String content){
		assert content != null;
		
	    contentToInfer = content;
	    calendar = Calendar.getInstance();
	    currentDay = calendar.get(Calendar.DAY_OF_WEEK);
	    if(currentDay == 1){
	    	currentDay = 7;
	    }else{
	    	currentDay -= 1;
	    }
	    now = new Date();
	    days = new HashMap<String, Integer>();
	    days.put("monday", 1);
	    days.put("tuesday", 2);
	    days.put("wednesday", 3);
	    days.put("thursday", 4);
	    days.put("friday", 5);
	    days.put("saturday", 6);
	    days.put("sunday", 7);
	    days.put("mon", 1);
	    days.put("tue", 2);
	    days.put("tues", 2);
	    days.put("wed", 3);
	    days.put("thur", 4);
	    days.put("thurs", 4);
	    days.put("fri", 5);
	    days.put("sat", 6);
	    days.put("sun", 7);
	    
	    
	}
	
	/**
	 * Default Constructor
	 * 
	 * initalizes today's date and the day of the week only
	 */
	
	public InferDateUtil(){
	    calendar = Calendar.getInstance();
	    now = new Date();
	    currentDay = calendar.get(Calendar.DAY_OF_WEEK);
	}
	
	/**
	 * finds a possible date that is implied within the content and stores it.
	 * 
	 * @return true if found else false.
	 * 
	 */
	
	public boolean findDate(){
		
		if(new Scanner(contentToInfer).findInLine("tmr") != null
				|| new Scanner(contentToInfer).findInLine("tommorrow") != null){
			calendar.setTime(now);
		    calendar.add(Calendar.DAY_OF_YEAR, 1);
		    inferredDate = sdfDate.format(calendar.getTime());
		 
		    return true;
		}
		Scanner sc = new Scanner(contentToInfer);
		if(sc.findInLine("this") != null){
			if(sc.hasNext()){
				String check = sc.next().toLowerCase();
				
				if(check.equals("this")){
					check = sc.next().toLowerCase();
				}
				
				if(days.containsKey(check)){
					inferredDay = days.get(check);
					
					
					if(inferredDay - currentDay <= 0){
						calendar.add(Calendar.DAY_OF_YEAR, inferredDay - currentDay + 7);
						inferredDate = sdfDate.format(calendar.getTime());
						sc.close();
						return true;
					}else{
						calendar.add(Calendar.DAY_OF_YEAR, inferredDay - currentDay );
						inferredDate = sdfDate.format(calendar.getTime());
						sc.close();
						return true;
					}
					
				}while(sc.hasNext()){
					if(sc.next().equals("this") && sc.hasNext()){
						check = sc.next().toLowerCase();
						
						if(days.containsKey(check)){
							inferredDay = days.get(check);
							
							if(inferredDay - currentDay <= 0){
								calendar.add(Calendar.DAY_OF_YEAR, inferredDay - currentDay + 7);
								inferredDate = sdfDate.format(calendar.getTime());
								sc.close();
								return true;
								
							}else{
								calendar.add(Calendar.DAY_OF_YEAR, inferredDay - currentDay );
								inferredDate = sdfDate.format(calendar.getTime());
								sc.close();
								return true;
							}
						}
					
					
					}
				}
			} 
				
		}
		sc.close();
		Scanner vc = new Scanner(contentToInfer);
		if(vc.findInLine("next") != null){
			if(vc.hasNext()){
				String check = vc.next().toLowerCase();
				
				if(check.equals("week")){
					calendar.add(Calendar.DAY_OF_YEAR, 7);
					inferredDate = sdfDate.format(calendar.getTime());
					vc.close();
					return true;
				}
				if(days.containsKey(check)){
					inferredDay = days.get(check);
					
					if(inferredDay - currentDay <= 0){
						calendar.add(Calendar.DAY_OF_YEAR, inferredDay - currentDay + 14);
						inferredDate = sdfDate.format(calendar.getTime());
						vc.close();
						return true;
						
					}else{
						calendar.add(Calendar.DAY_OF_YEAR, inferredDay - currentDay + 7);
						inferredDate = sdfDate.format(calendar.getTime());
						vc.close();
						return true;
					}
					
				}
			}
		}
		vc.close();
		return false;
	}
	
	/**
	 * Getter to obtain date inferred from content.
	 * 
	 * @return null if there is no date. 
	 */
	public String getDate(){
		
	    return inferredDate;
	
	
	}
}
```
###### /java/seedu/address/logic/commands/UndoCommand.java
``` java
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String MESSAGE_SUCCESS = "Previous command has been undone";
    public static final String UNDO_ADD_MESSAGE = "Added Task has been deleted";
	public static final String UNDO_DELETE_MESSAGE = "Removed Task has been re-added";
	public static final String EMPTY_HISTORY_MESSAGE = "No available commands can be undone";
	public static final String UNDO_SORT_MESSAGE = "Sorting has been undone";
	public static final String UNDO_EDIT_MESSAGE = "Edits has been revoked";
	public static final String UNDO_CLEAR_MESSAGE = "Deleted Tasks have been restored";
	public static final String UNDO_DONE_MESSAGE = "Task has been marked undone";
	public static final String UNDO_ADD_TAG_MESSAGE = "Tag/s have been removed";
	public static final String UNDO_DEL_TAG_MESSAGE = "Tag/s have been re-added";
	
	
    public UndoCommand() {}


    @Override
    public CommandResult execute() {
        assert model != null;
        
        if (model.getHistory().isEmpty() ) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(EMPTY_HISTORY_MESSAGE);
        }
        try {
			model.undo();
		} catch (StateNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        String messageType = model.getHistory().getMessage();
        switch (messageType){
        	case "add":
        		return new CommandResult(UNDO_ADD_MESSAGE);
        	case "clear":
        		return new CommandResult(UNDO_CLEAR_MESSAGE);
        	case "delete":
        		return new CommandResult(UNDO_DELETE_MESSAGE);
        	case "sort" :
        		return new CommandResult(UNDO_SORT_MESSAGE);
        	case "edit" :
        		return new CommandResult(UNDO_EDIT_MESSAGE);
        	case "done" :
        		return new CommandResult(UNDO_DONE_MESSAGE);
        	case "addTag" :
        		return new CommandResult(UNDO_ADD_TAG_MESSAGE);
        	case "deleteTag":
        		return new CommandResult(UNDO_DEL_TAG_MESSAGE);
        	default:
        		return new CommandResult(MESSAGE_SUCCESS);
        
        }
        	
        	
    }
}
```
###### /java/seedu/address/logic/commands/FindTagCommand.java
``` java
public class FindTagCommand extends Command {

    public static final String COMMAND_WORD = "findtag";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose tags contain any of "
            + "the specified tag (alphanumeric) and displays them as a list with index numbers.\n"
            + "Parameters: NAME_OF_TAG...\n"
            + "Example: " + COMMAND_WORD + " CS2103";

    private final Tag tagToFind;

    public FindTagCommand(String tagname) throws IllegalValueException {
        this.tagToFind = new Tag(tagname);
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(tagToFind);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### /java/seedu/address/logic/commands/FindCommand.java
``` java
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose names contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " go to tutorial";

    private final String keywords;

    public FindCommand(String keywords) {
        this.keywords = keywords.toLowerCase();
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### /java/seedu/address/logic/commands/AddTagCommand.java
``` java
public class AddTagCommand extends Command {
    public static final String COMMAND_WORD = "addtag";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": adds a tag to a task listed in the task manager. \n"
            + "Parameters: INDEX[MUST BE POSITIVE INTEGER] TAGS[ANY NUMBER OF TAGS SEPARATED BY SPACE] \n"
            + "Example: " + COMMAND_WORD
            + " 1 toughlife easygame";
    
    public static final String MESSAGE_INVALID_TAG = "Tags must be alphanumerical";
    public static final String MESSAGE_NO_TAG = "No Tag can be found";
    public static final String MESSAGE_SUCCESS = "Task tags updated: %1$s";
    
 
    private int targetIndex;
    private ArrayList<String> tagsToAdd;


    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     * @throws ParseException 
     */
   
	public AddTagCommand(String index, String tagsString)
            throws IllegalValueException, ParseException {
    		this.targetIndex = Integer.parseInt(index.trim());
    		tagsToAdd = new ArrayList<String>();
    		
    		Scanner sc = new Scanner(tagsString.trim());
    			while(sc.hasNext()){
    				String tagToAdd = sc.next();
    				tagsToAdd.add(tagToAdd);
    			}
    		
    		
    		sc.close();
        
    }

    @Override
    public CommandResult execute() {
    	UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        if(tagsToAdd.size() == 0)
        	return new CommandResult(MESSAGE_NO_TAG);
        
        ReadOnlyTask taskToAddTags= lastShownList.get(targetIndex - 1);
        
        try {
            model.addTags(taskToAddTags, tagsToAdd);
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        } catch (ParseException pe){
        	return new CommandResult("ParseException");
        } catch (IllegalValueException ive){
        	return new CommandResult(MESSAGE_INVALID_TAG);
        }
       lastShownList = model.getFilteredTaskList();
        ReadOnlyTask updatedTask = lastShownList.get(targetIndex - 1);
        return new CommandResult(String.format(MESSAGE_SUCCESS, updatedTask));
    }
}
```
###### /java/seedu/address/logic/parser/Parser.java
``` java
	private Command prepareEdit(String args) throws ParseException {
		final Matcher matcher = EDIT_TASK_ARGS_FORMAT.matcher(args.trim());
		// Validate arg string format
		if (!matcher.matches()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		}
		try {
			return new EditCommand(matcher.group("index"), matcher.group("taskDetails"));

		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}
	}

	/**
	 * Parses arguments in the context of the add task command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 * @throws ParseException
	 */
	private Command prepareAdd(String args) throws ParseException {

		Scanner validator = new Scanner(args);
		// Validate arg string format: String cannot be empty or null
		if (args == null || args.isEmpty()) {
			validator.close();
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));

		} else {
			// Validate arg string format: String starts with content and not
			// date/time/tag
			String startOfLine = validator.next();

			if (startOfLine.startsWith("sd/") || startOfLine.startsWith("st/") || startOfLine.startsWith("#")
					|| startOfLine.startsWith("et/") || startOfLine.startsWith("ed/") || startOfLine.startsWith("r/")) {
				validator.close();
				return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
			}

		}
		validator.close();

		// Obtain content of Task from String args
		Scanner scanContent = new Scanner(args);
		StringBuilder content = new StringBuilder();
		while (scanContent.hasNext()) {
			String check = scanContent.next();
			if (check.startsWith("sd/") || check.startsWith("st/") || check.startsWith("#") || check.startsWith("et/")
					|| check.startsWith("ed/") || check.startsWith("r/"))
				break;
			else
				content.append(" " + check);
		}
		scanContent.close();

		// Obtain set of tags if any from String args
		Set<String> setTags = new HashSet<String>();
		Scanner scanTags = new Scanner(args);
		if (scanTags.findInLine("#") != null) {
			setTags.add(scanTags.next());
			while (scanTags.findInLine("#") != null) {
				setTags.add(scanTags.next());
			}

		} else {
			setTags = Collections.emptySet();
		}
		scanTags.close();

		// Obtain date if any from String args
		String dateString = null;
		Scanner scanDate = new Scanner(args);
		if (scanDate.findInLine("sd/") != null) {
			dateString = scanDate.next();
		}
		scanDate.close();

		// Obtain time if any from String args
		String timeString = null;
		Scanner scanTime = new Scanner(args);
		if (scanTime.findInLine("st/") != null) {
			timeString = scanTime.next();
		}
		scanTime.close();

		// Obtain endTime if any from String args
		String endTimeString = null;
		Scanner scanEndTime = new Scanner(args);
		if (scanEndTime.findInLine("et/") != null) {
			endTimeString = scanEndTime.next();
		}

		scanEndTime.close();

		// Obtain endDate if any from String args
		String endDateString = null;
		Scanner scanEndDate = new Scanner(args);
		if (scanEndDate.findInLine("ed/") != null) {
			endDateString = scanEndDate.next();
		}
		scanEndDate.close();

		// Obtain duration if any from String args
		Integer duration = null;
		Scanner scanDuration = new Scanner(args);
		if (scanDuration.findInLine("r/") != null) {
			duration = scanDuration.nextInt();
		}
		scanDuration.close();

		try {
			return new AddCommand(content.toString().trim(), dateString, endDateString, timeString, endTimeString,
					duration, setTags);

		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}
	}

```
###### /java/seedu/address/logic/parser/Parser.java
``` java
	private Command prepareFind(String args) {
		final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
		if (!matcher.matches()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
		}
		final String keywords = matcher.group("keywords");
		// keywords delimited by whitespace
		// final String[] keywords = matcher.group("keywords").split("\\s+");
		// final Set<String> keywordSet = new
		// HashSet<>(Arrays.asList(keywords));
		return new FindCommand(keywords);
	}

	/**
	 * Parses arguments in the context of the findtag task command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 * @throws IllegalValueException
	 */
	private Command prepareFindTag(String args) {
		final Matcher matcher = FIND_TAG_FORMAT.matcher(args.trim());
		if (!matcher.matches()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindTagCommand.MESSAGE_USAGE));
		}
		final String keywords = matcher.group("tagname");
		try {
			return new FindTagCommand(keywords);
		} catch (IllegalValueException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindTagCommand.MESSAGE_USAGE));
		}
	}
}
```
